!SESSION 2019-03-27 03:55:56.487 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-03-27 03:56:35.168
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-03-27 03:56:35.267
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.lejos.ev3.ldt 4 0 2019-03-27 03:58:13.347
!MESSAGE EV3_HOME is not set. Please specify it in the plug-in's preferences
!STACK 0
org.lejos.ev3.ldt.util.LeJOSEV3Exception: EV3_HOME is not set. Please specify it in the plug-in's preferences
	at org.lejos.ev3.ldt.util.LeJOSEV3Util.getEV3Home(LeJOSEV3Util.java:219)
	at org.lejos.ev3.ldt.ant.EV3HomeProvider.getAntPropertyValue(EV3HomeProvider.java:15)
	at org.eclipse.ant.core.Property.getValue(Property.java:123)
	at org.eclipse.ant.internal.ui.model.AntModel.setGlobalProperties(AntModel.java:551)
	at org.eclipse.ant.internal.ui.model.AntModel.setProperties(AntModel.java:461)
	at org.eclipse.ant.internal.ui.model.AntModel.initializeProject(AntModel.java:429)
	at org.eclipse.ant.internal.ui.model.AntModel.prepareForFullParse(AntModel.java:396)
	at org.eclipse.ant.internal.ui.model.AntModel.parseDocument(AntModel.java:355)
	at org.eclipse.ant.internal.ui.model.AntModel.reconcile(AntModel.java:313)
	at org.eclipse.ant.internal.ui.model.AntModel.getProjectNode(AntModel.java:1518)
	at org.eclipse.ant.internal.ui.model.AntModel.getProjectNode(AntModel.java:1531)
	at org.eclipse.ant.internal.ui.datatransfer.AntNewJavaProjectPage$1.modifyText(AntNewJavaProjectPage.java:92)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:180)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4247)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1508)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Text.setText(Text.java:2205)
	at org.eclipse.ant.internal.ui.datatransfer.AntNewJavaProjectPage.handleBrowseButtonPressed(AntNewJavaProjectPage.java:296)
	at org.eclipse.ant.internal.ui.datatransfer.AntNewJavaProjectPage.access$7(AntNewJavaProjectPage.java:281)
	at org.eclipse.ant.internal.ui.datatransfer.AntNewJavaProjectPage$3.widgetSelected(AntNewJavaProjectPage.java:237)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:249)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4247)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1508)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1516)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1320)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4091)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3712)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:818)
	at org.eclipse.jface.window.Window.open(Window.java:794)
	at org.eclipse.ui.actions.NewProjectAction.run(NewProjectAction.java:115)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:565)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:397)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4247)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1508)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1516)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1320)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4091)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3712)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1170)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1059)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:667)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-03-27 03:58:20.145
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-03-27 04:41:29.772
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-03-27 20:57:19.957 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-03-27 20:57:26.669
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-03-27 20:57:26.763
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-03-27 20:57:36.289
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-03-27 21:54:57.733
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:15.945
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new Pentag

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:15.950
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:15.951
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:30.060
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new PentagCoord(())

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:30.061
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:30.062
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:31.576
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new PentagCoord((6,))

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:31.578
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:31.578
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:33.605
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new PentagCoord(())

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:33.606
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:33.607
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:37.128
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new PentagCoord((5, 0))

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:37.128
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:37.129
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-27 22:23:38.653
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {

	private Piece[][] board;
	
	private PentagoCoord TL = new PentagoCoord(0, 0);
	private PentagoCoord TR = new PentagCoord((5, 0));

	private enum Pattern {
		five, four, three, two, one
	}
	
    /**
     * You must modify this constructor to return your student number. This is
     * important, because this is what the code that runs the competition uses to
     * associate you with your agent. The constructor should do nothing else.
     */
    public StudentPlayer() {
        super("260732931");
    }

    /**
     * This is the primary method that you need to implement. The ``boardState``
     * object contains the current state of the game, which your agent must use to
     * make decisions.
     */
    public Move chooseMove(PentagoBoardState boardState) {
        // You probably will make separate functions in MyTools.
        // For example, maybe you'll need to load some pre-processed best opening
        // strategies...
        MyTools.getSomething();
        
        update(boardState);
        ArrayList<PentagoMove> allLeagalMoves = boardState.getAllLegalMoves();
        Move myMove = boardState.getRandomMove();
        
        
        
        
        

        // Return your move to be processed by the server.
        return myMove;
    }
    
	// Count the number of cases where two pieces is consecutively in a row
    
    
	
	// Count the number of cases where three pieces is consecutively in a row
	
	
	public static int calStateHeuristic(PentagoBoardState boardState) {
		// Determine the player number of us
		int player;
		int opp = boardState.getOpponent();
		if(opp == 1) {
			player = 0;
		} else {
			player = 1;
		}
		
		
		int heuristicVal = 0;
		for(int i = 0; i<6; i++) {
			heuristicVal += scoreTable(checkForPattern(player,))
		}
	
		return heuristicVal;
	}
	
	/**
	 * This method is used to check for the particular pattern of the board.
	 * @param player which player we are
	 * @param start	the starting coordinate
	 * @param direction which direction to check for the pattern (row/vertical/diagonal)
	 * @param state current boardstate of the game
	 * @return
	 */
    private int[]checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction, PentagoBoardState state) {
    	int[] result = new int[2];
        int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        PentagoCoord current = start;
        if(Piece.EMPTY == board[current.getX()][current.getX()]) notBlocked = 1;
        while(true) {
            try {
                if (currColour == board[current.getX()][current.getY()]) {
                    counter++;
                    current = direction.apply(current);
                } else {
                	if(Piece.EMPTY == board[current.getX()][current.getY()]) notBlocked++;
                    break;
                }
            } catch (IllegalArgumentException e) { //We have run off the board
                break;
            }
        }
        result[0] = counter;
        result[1] = notBlocked;
        return result;
    }
    
    /**
     * This method is used to update the board state of the game.
     * @param state
     */
    private void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
	
    /**
     * This method returns the heuristic socre of the current state.
     * @param p
     * @param notBlocked
     * @return 
     */
    private int scoreTable(int[] pair) {
    	if(pair[0] == 5) {
    		return 100000;
    	} else if(pair[0] == 4) {
    		if(pair[1] == 2) {
    			return 10000;
    		} else if(pair[1] == 1) {
    			return 1000;
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 1000;
    		} else if (pair[1] == 1) {
    			return 100;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 100;
    		} else if (pair[1] == 1) {
    			return 10;
    		}
    	} else if (pair[0] == 1 && pair[1] == 2) {
    		return 10;
    	}
    	return 0;
    }
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-27 22:23:38.655
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-27 22:23:38.655
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.ui 4 0 2019-03-27 22:37:17.153
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4552)
	at org.eclipse.swt.SWT.error(SWT.java:4467)
	at org.eclipse.swt.SWT.error(SWT.java:4438)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:806)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:593)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3888)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setFocus(AbstractAnnotationHover.java:211)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformationControl(AbstractInformationControlManager.java:1287)
	at org.eclipse.jface.internal.text.StickyHoverManager.showInformationControl(StickyHoverManager.java:264)
	at org.eclipse.jface.internal.text.InformationControlReplacer.showInformationControl(InformationControlReplacer.java:161)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1175)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1161)
	at org.eclipse.jface.text.AbstractInformationControlManager.setInformation(AbstractInformationControlManager.java:428)
	at org.eclipse.jface.internal.text.InformationControlReplacer.computeInformation(InformationControlReplacer.java:113)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1142)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformation(AbstractInformationControlManager.java:1132)
	at org.eclipse.jface.internal.text.InformationControlReplacer.replaceInformationControl(InformationControlReplacer.java:100)
	at org.eclipse.jface.text.AbstractInformationControlManager.replaceInformationControl(AbstractInformationControlManager.java:1309)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.replaceInformationControl(AbstractHoverInformationControlManager.java:801)
	at org.eclipse.jface.text.TextViewerHoverManager.replaceInformationControl(TextViewerHoverManager.java:308)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$Closer$2.run(AbstractHoverInformationControlManager.java:301)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:37)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1170)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1059)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:667)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)
!SESSION 2019-03-31 21:11:06.299 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.resources 2 10035 2019-03-31 21:11:12.112
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.core.net 1 0 2019-03-31 21:11:13.294
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-03-31 21:11:13.390
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-03-31 21:14:19.736
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-03-31 21:58:09.091
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-04-01 17:46:33.560 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-01 17:46:40.893
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-01 17:46:40.978
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-01 17:47:24.519
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-01 17:59:08.205
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-04-03 16:09:51.532 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-03 16:10:03.232
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-03 16:10:03.417
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-03 16:10:17.184
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-03 17:07:03.536
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.

!ENTRY org.eclipse.jdt.core 4 4 2019-04-03 17:46:52.378
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package pentago_swap;

import java.util.ArrayList;
import java.util.function.UnaryOperator;

import boardgame.Move;
import pentago_swap.PentagoBoardState.Piece;




/**
 * @author mgrenander
 */
public class RandomPentagoPlayer extends PentagoPlayer {
	
	
	public int AI = -1;
	public int Opp = ;
	
	
    public RandomPentagoPlayer() {
        super("RandomPlayer");
    }

    public RandomPentagoPlayer(String name) {
        super(name);
    }

    @Override
    public Move chooseMove(PentagoBoardState boardState) {
        return minimax(2, boardState.getTurnPlayer(), Integer.MIN_VALUE, Integer.MAX_VALUE, boardState, boardState.getTurnPlayer()).getMove();
    	//return boardState.getRandomMove();
    }
    
   
	private Piece[][] board = new Piece[6][6];
	private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    
	public Node minimax(int depth, int player, int alpha, int beta, PentagoBoardState boardState) {
		updateBoard(boardState);
		PentagoBoardState cloneState = (PentagoBoardState) boardState.clone();
		ArrayList<PentagoMove> moves = cloneState.getAllLegalMoves();
		int score;
		Node bestMove = new Node(); 
		//PentagoMove bestMove = null;
		
		//my player is maximizing; while the opponent player is minimizing 
		
		System.out.println("ai = "+AI);
		System.out.println("op = "+opp);
		
		
		if(!moves.isEmpty() && depth!=0) {

			for(PentagoMove move: moves) {
				//System.out.println(move.toPrettyString());
				PentagoBoardState newClone= (PentagoBoardState) cloneState.clone();
				newClone.processMove(move); //will the cloneState change every time
				if (player==AI) {//maximizing
					//System.out.println("op"+newClone.getOpponent());
					//System.out.println("myplayer"+player);
					score=minimax(depth-1,opp,alpha, beta, newClone).getScore();
					//System.out.println(score);
					System.out.println("alpha = "+alpha);
					if(score > alpha) {
						System.out.println("hi,im in the if statement");
						alpha = score;
						//System.out.println("alpha = "+alpha);
						//System.out.println(move.toPrettyString());
						bestMove.setMove(move);
					}
				}
				else { //opponent 
					score=minimax(depth-1,AI,alpha,beta,newClone).getScore();
					if(score<beta) {
						beta=score;
						bestMove.setMove(move);
						System.out.println("beta = "+beta);
					}
				}
				if(alpha>=beta) break;
			}
			if(player== AI) {
				Node rs = new Node(bestMove.getMove(),alpha);
				//rs.getMove().toPrettyString();
				return rs;
			}
			else {
				Node rs = new Node(bestMove.getMove(),beta);
				//rs.getMove().toPrettyString();
				return rs;
			}
			
		
		}
		else{		//when depth=0
			
			score= heuristic(AI,cloneState)-heuristic(opp,cloneState);		//pass in game state
			bestMove.setScore(score);
			System.out.println("score = "+score);
			//System.out.println(bestMove.getScore());
			return bestMove;
			
		}
		}
	
	//calculate the heuristic for both player
    public int heuristic(int player, PentagoBoardState state) {
    		int accumScore=0;
    		PentagoCoord startY =new PentagoCoord(0,0);
    		PentagoCoord startX =new PentagoCoord(0,0);
    		//check vertical both diagonal
    		for(int i=0;i<6;i++) {
    			int[] Situation2 = new int[2];
    			Situation2= checkSituation(player, startY, getNextVertical,state);
    			
    			accumScore = scoreTable(Situation2[0],Situation2[1])+ accumScore;
    			int[] Situation3= checkSituation(player, startY, getNextDiagRight,state);
    			accumScore = scoreTable(Situation3[0],Situation3[1])+ accumScore;
    			int[] Situation4= checkSituation(player, startY, getNextDiagLeft,state);
    			accumScore = scoreTable(Situation4[0],Situation4[1])+ accumScore;
    			if(i!=5) {
    				startY=  getNextHorizontal.apply(startY);
    				i++;
    			}
    		}
    		for(int i=0;i<6;i++) {
    			int[] Situation5= checkSituation(player,startX, getNextHorizontal,state);
    			accumScore = scoreTable(Situation5[0],Situation5[1])+ accumScore;
    			if(i!=5) {
    				startX= getNextVertical.apply(startX);
    				i++;
    			}
    		}
    		return accumScore;
    }
    
    public void updateBoard(PentagoBoardState bs) {
		for(int i=0;i<6;i++) {
			for(int j=0;j<6;j++) {
				board[i][j] = bs.getPieceAt(i,j);
			}
		}
	}
    
  //set the heuristic value for each situation
    public int scoreTable (int number, int emptySide) {
    		if(number >=5) {
    			return 100000;
    		}
    		else if(number ==4) {
    			if (emptySide ==2) return 10000;
    			else return 1000;
    		}
    		else if(number ==3) {
    			if(emptySide==2) return 1000;
    			else return 100;
    		}
    		else if(number ==2) {
    			if(emptySide==2) return 100;
    			else return 10;
    		}
    		else if(number ==1) {
    			if(emptySide==2) return 10;
    			else return 0;
    		}
    		return 0;
    }
    
    private int[] checkSituation(int player, PentagoCoord board, UnaryOperator<PentagoCoord> direction, PentagoBoardState state){
		int[] result = new int[2];
		int sameColor=0;
		int blockSide=0;
		updateBoard(state);
		PentagoCoord current= board;
		Piece color= player==0 ? Piece.WHITE : Piece.BLACK;
		while(true) {
			try {
    			if(color== this.board[current.getX()][current.getY()]) {
    				sameColor++;
    				if(current.getX()==0 || current.getX()==5) blockSide++;
    				if(current.getY()==0 || current.getY()==5) blockSide++;
    				current= direction.apply(current);
    			}
    			else if (color!= Piece.BLACK || color!=Piece.WHITE) {
    				current= direction.apply(current);
    			}
    			else if (color !=this.board[current.getX()][current.getY()]){
    				blockSide++;
    				current= direction.apply(current);
    			}
    			else break;

    		}catch(IllegalArgumentException e) {
    			break;
    		}
		} 		
		int emptySide= 2-blockSide;
		result[0] = sameColor;
		result[1] = emptySide;
		
		return result;
}
	
	
	public class Node{
		PentagoMove move;
		int heuristic;
		
		public Node() {
		}
		
		public Node(PentagoMove move, int heuristic) {
			this.move=move;
			this.heuristic = heuristic;
		}
		
		public Node(int heuristic) {
			this.heuristic=heuristic;
		}
		public PentagoMove getMove()
		{
			return this.move;
		}
		public int getScore() {
			return this.heuristic;
		}
		public void setScore(int heuristic) {
			this.heuristic=heuristic;
		}
		public void setMove(PentagoMove move) {
			this.move=move;
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-03 17:46:52.404
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-03 17:46:52.405
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3295)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:444)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:194)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2019-04-05 14:58:02.349 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-05 14:58:17.486
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-05 14:58:17.581
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-05 15:22:32.252
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-05 15:56:35.938
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-04-09 22:17:32.452 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-09 22:17:59.004
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-09 22:17:59.101
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-09 22:21:20.454
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-09 22:40:19.653
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:24:32.418
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:24:32.446
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:24:32.446
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:24:41.006
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:24:41.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:24:41.007
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:24:43.037
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, )
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:24:43.038
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:24:43.039
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:32.538
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:32.539
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:32.540
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:36.081
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:36.081
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:36.082
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:41.134
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:41.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:41.135
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:47.693
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AIInteger.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:47.693
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:47.694
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:48.716
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:48.717
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:48.717
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:49.736
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AIInteger.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:49.737
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:49.737
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:50.763
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:50.764
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:50.764
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:54.802
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, )
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:54.803
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:54.803
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:28:57.854
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:28:57.855
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:28:57.855
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:29:02.908
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long startTime, long)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:29:02.908
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:29:02.909
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:29:03.928
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long startTime, long )
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:29:03.929
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:29:03.929
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:29:05.453
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long startTime, long timne)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:29:05.454
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:29:05.454
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:29:06.470
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long startTime, long tim)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:29:06.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:29:06.471
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2019-04-10 15:29:08.503
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package student_player;

import java.util.ArrayList;
import java.util.Random;
import java.util.function.UnaryOperator;

import boardgame.Move;

import pentago_swap.PentagoPlayer;
import pentago_swap.PentagoBoardState.Piece;
import pentago_swap.PentagoBoardState.Quadrant;
import pentago_swap.PentagoBoardState;
import pentago_swap.PentagoCoord;
import pentago_swap.PentagoMove;

/** A player file submitted by a student. */
public class StudentPlayer extends PentagoPlayer {
	private int counter = 0;
	private static Piece[][] board = new Piece[6][6];
	private static int AI = -1;
	private static int Opp = -1;
	private boolean winningMoveFound = false;
	
	private static int INITIAL_DEPTH;
	private static int currentDepth;
	
	private PentagoMove globalBestMove;
	private PentagoMove localBestMove;
	
	private static long firstMove = 29000;
	private static long roundMove = 1950;
	private static long startTime;
	
	private static boolean timeout;
	
    public StudentPlayer() {
        super("260732931");
    }
    
    public Move chooseMove(PentagoBoardState boardState) {
    	startTime = System.currentTimeMillis();
    	
    	timeout = false;
    	long start = System.currentTimeMillis();
    	
    	if (AI == -1 || Opp == -1) {
    		AI = boardState.getTurnPlayer();
    		Opp = boardState.getOpponent();
    	}
    	
    	for(int depth = 0;;depth++) {
    		if(depth > 0) {
    			globalBestMove = localBestMove;
    			 System.out.println("Completed search with depth " + depth + ". Best move so far: " + globalBestMove);
    		}
    		currentDepth = INITIAL_DEPTH + depth;
    		alphaBeta(boardState, currentDepth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE).getMove();
    		if(timeout) {
    			System.out.println("Time out!");
    			return globalBestMove;
    		}
    	}
    }
    
    private static final UnaryOperator<PentagoCoord> getNextHorizontal = c -> new PentagoCoord(c.getX(), c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextVertical = c -> new PentagoCoord(c.getX()+1, c.getY());
    private static final UnaryOperator<PentagoCoord> getNextDiagRight = c -> new PentagoCoord(c.getX()+1, c.getY()+1);
    private static final UnaryOperator<PentagoCoord> getNextDiagLeft = c -> new PentagoCoord(c.getX()+1, c.getY()-1);
    
    private static void update(PentagoBoardState state) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
    			board[i][j] = state.getPieceAt(i, j);
    		}
    	}
    }
    
    private int iterativeDeepeningSearch(PentagoBoardState state, long timeLimit) {
    	long startTime = System.currentTimeMillis();
    	long endTime = startTime + timeLimit;
    	int depth = 2;
    	int score = 0;
    	timeout = false;
    	
    	while(true) {
    		long currentTime = System.currentTimeMillis();
    		
    		if(currentTime >= endTime) {
    			break;
    		}
    		int searchResult = alphabeta(state, depth, AI, Integer.MIN_VALUE, Integer.MAX_VALUE, currentTime, endTime - currentTime);
    	}
    	
    }
    
    
    
    
    
    
    private int alphaBetaSearch(PentagoBoardState state, int depth, int player, int alpha, int beta, long startTime, long timeLimit)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Node alphaBeta(PentagoBoardState state, int depth, int player, int alpha, int beta) {
    	
    	update(state);
    	ArrayList<PentagoMove> nextMoves = state.getAllLegalMoves();		// 	Create a list of possible moves
    	int score;
    	
    	Node bestMove = new Node();
    	if(nextMoves.isEmpty() || depth == 0) {
    		score = calStateHeuristic(AI) - calStateHeuristic(Opp);
    		//System.out.println("Score = " + score);
    		bestMove.setHeuristic(score);
    		return bestMove;
    		
    	} else {
    		for(PentagoMove move: nextMoves) {
    			
    			PentagoBoardState newClonedState = (PentagoBoardState)state.clone();
    			newClonedState.processMove(move);  
    			
    			if(player == AI) {	// is maximizing player
        			if(newClonedState.getWinner() == AI) {
        				bestMove.setMove(move);
        				return bestMove;
        			}
    				score = alphaBeta(newClonedState, depth - 1, Opp, alpha, beta).getHeuristic();
    				if(score > alpha) {
    					alpha = score;
    					// System.out.println("Alpha = " + alpha);
    					bestMove.setMove(move);
    				}
    			} else {
    				score = alphaBeta(newClonedState, depth - 1, AI, alpha, beta).getHeuristic();
    				if(score < beta) {
    					beta = score;
    					// System.out.println("Beta = " + beta);
    					bestMove.setMove(move);
    				}
    			}
    			if (alpha > beta ) break;
    		}
    	}
    	
		if(player == AI) {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(alpha);
			return result;
			
		} else {
			
			Node result = new Node();
			result.setMove(bestMove.getMove());
			result.setHeuristic(beta);
			return result;
		}
    }
    
    private int scoreTable(int[] pair) {
    	//System.out.println("Streak: " + pair[0] + " " + "Not blocked: " + pair[1]);
    	if(pair[0] >= 5) {			// ooooo
    		return 300000;
    	} else if(pair[0] == 4) {	
    		if(pair[1] == 2) {	 // -oooo-
    			return 300000;
    		} else if(pair[1] == 1) {			// xoooox or -oooox
    			return 3000; //3000
    		} else {
    			return 2000; //2000
    		}
    	} else if (pair[0] == 3) {
    		if(pair[1] == 2) {
    			return 5000;
    		} else if (pair[1] == 1){
    			return 4000; //800
    		} else {
    			return 3000;
    		}
    	} else if (pair[0] == 2) {
    		if(pair[1] == 2) {
    			return 1500;
    		} else if (pair[1] == 1){
    			return 800;
    		}
    	} else if (pair[0] == 1) {
    		if(pair[1] == 2) {
    			return 500;
    		} else {
    			return 0;
    		}
    	}
    	return 0;
    }  
    
	public int calStateHeuristic(int player) {
		PentagoCoord BL = new PentagoCoord(0, 5);
		// Determine the player number of u
		// System.out.println("Player: " + player);
		int heuristicVal = 0;
		// Check patterns for col
		PentagoCoord TLRow = new PentagoCoord(0, 0);
		// PentagoCoord TRD = new PentagoCoord();
		for(int i = 0; i<6; i++) {
			int value = checkForPattern(player, TLRow, getNextVertical);
			heuristicVal += value;
			if(i!=5) {
				TLRow = getNextHorizontal.apply(TLRow);
			}
			//System.out.println("Col" + i + " = " + value);
		}
		// Check patterns for diagonally left
		PentagoCoord DR = new PentagoCoord(0, 0);
		int dr = checkForPattern(player, DR, getNextDiagRight);
		// System.out.println("Main diagonal LL: " + dr);
		heuristicVal += dr;
		// System.out.println("DR" + " = " + dr);
		// Check patterns for diagonally right 
		PentagoCoord TLDR = new PentagoCoord(0, 5);
		int dl = checkForPattern(player, TLDR, getNextDiagLeft);
		heuristicVal += dl;
		// System.out.println("Reverse main diagonal " + " = " + dl);
		
		PentagoCoord TLCol = new PentagoCoord(0, 0);
		// Check patterns for row
		for(int i=0; i<6; i++) {
			int value = checkForPattern(player, TLCol, getNextHorizontal);
			heuristicVal += value;
			if(i!=5) {
				TLCol = getNextVertical.apply(TLCol);
			}
			// System.out.println("Row" + i + " = " + value);
		}
		
		PentagoCoord TDUL = new PentagoCoord(0, 1);
		int dul = checkForPattern(player, TDUL, getNextDiagRight);
		heuristicVal += dul;
		// System.out.println("Main diagonal + 1 = " + dul);
		
		PentagoCoord TDLL = new PentagoCoord(1, 0);
		int dll = checkForPattern(player, TDLL, getNextDiagRight);
		heuristicVal += dll;
		// System.out.println("Main diagonal - 1 = " + dll);
		
		PentagoCoord TDUR = new PentagoCoord(0, 4);
		int dur = checkForPattern(player, TDUR, getNextDiagLeft);
		heuristicVal += dur;
		// System.out.println("Reverse main diagonal + 1 = " + dur);
		
		PentagoCoord TDLR = new PentagoCoord(1, 5);
		int dlr = checkForPattern(player, TDLR, getNextDiagLeft);
		heuristicVal += dlr;
		// System.out.println("Reverse main diagonal - 1 = " + dlr);
		
		return heuristicVal;
	}
	
    private int checkForPattern(int player, PentagoCoord start, UnaryOperator<PentagoCoord> direction) {
    	boolean firstQuardant = true;
    	boolean secondQuadrant = true;
    	int index = 0;
    	int score = 0;
    	int counter = 0;
        int notBlocked = 0;
        Piece currColour = player == 0 ? Piece.WHITE : Piece.BLACK;
        Piece oppColour = player == 0 ? Piece.BLACK : Piece.WHITE;
        // System.out.println(currColour.name());
        PentagoCoord current = start;
        PentagoCoord previous = start;
        if(this.board[current.getX()][current.getY()] == Piece.EMPTY) notBlocked = 1;
        while(true) {
            try {
            	// The next coord is the same as the previous for the target player
                if (currColour == board[current.getX()][current.getY()]) {
                	counter++;
                	if (board[previous.getX()][previous.getY()] == Piece.EMPTY) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	}
                	if (board[previous.getX()][previous.getY()] == oppColour && notBlocked>0) {
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                } else {
             		if(index <= 2) {
            			firstQuardant = false;
            		} else {
            			secondQuadrant = false;
            		}
                	if(board[current.getX()][current.getY()]==Piece.EMPTY && board[previous.getX()][previous.getY()] == currColour) {
                		if(notBlocked<2) {
                			notBlocked++;
                		}
                	} else {
  
                		if(notBlocked>0) {
                			notBlocked--;
                		}
                	}
                	if(counter>=1) {
                		score += scoreTable(new int[]{counter, notBlocked});
                		counter = 0;
                		notBlocked = 0;
                	}
                }
                previous = current;
                current = direction.apply(current);
                index++;
            } catch (IllegalArgumentException e) { //We have run off the board
            	if(counter >= 1) {
            		score += scoreTable(new int[]{counter, notBlocked});
            	}
            	if(firstQuardant == true) score += 5000;
            	if(secondQuadrant == true) score += 5000;
                break;
            }
        }
      return score;
    }
    
    private static void toStringBoard(Piece[][] aboard) {
    	for(int i=0; i<6; i++) {
    		for(int j=0; j<6; j++) {
        		System.out.print(aboard[i][j].name() + " ");
    		}
    		System.out.println();
    	}
    	System.out.println();
    	System.out.println();
    }
    
    class Node {
    	PentagoMove move;
    	int heuristic;
    	public Node() {
    	}
    	public Node(PentagoMove move, int heuristic) {
    		this.move = move;
    		this.heuristic = heuristic;
    	}
    	public PentagoMove getMove() {
    		return this.move;
    	}
    	public int getHeuristic() {
    		return this.heuristic;
    	}
    	public void setMove(PentagoMove move) {
    		this.move = move;
    	}
    	public void setHeuristic(int heuristic) {
    		this.heuristic = heuristic;
    	}
    }
    /*
    public static void main(String[] args) {
    	StudentPlayer sp = new StudentPlayer();
    	System.out.println("Testing...");
    	PentagoBoardState state = new PentagoBoardState();
    	PentagoMove move1 =  new PentagoMove( "0 0 BL BR 0");
    	PentagoMove move2 =  new PentagoMove( "1 0 BL BR 1");
    	PentagoMove move3 =  new PentagoMove( "0 1 BR BL 0");
    	PentagoMove move4 =  new PentagoMove( "0 5 BR BL 1");
    	PentagoMove move5 =  new PentagoMove( "0 2 BL BR 0");
    	//PentagoMove move6 =  new PentagoMove( "2 1 BL BR 1");
    	//PentagoMove move7 =  new PentagoMove( "5 1 TL BR 0");
    	//PentagoMove move8 =  new PentagoMove( "1 4 BL TR 1");
    	//PentagoMove move9 =  new PentagoMove( "3 4 BL BR 0");
    	//PentagoMove move10 =  new PentagoMove( "0 2 TL BR 1");
    	//PentagoMove move11 =  new PentagoMove( "1 4 TR BL 0");
    	//PentagoMove move12 =  new PentagoMove( "4 4 BL BR 1");
    	state.processMove(move1);
    	state.processMove(move2);
    	state.processMove(move3);
    	state.processMove(move4);
    	state.processMove(move5);
    	//state.processMove(move6);
    	//state.processMove(move7);
    	//state.processMove(move8);
    	//state.processMove(move9);
    	//state.processMove(move10);
    	//state.processMove(move11);
    	//state.processMove(move12);
    	update(state);
    	toStringBoard(board);
    	System.out.println(state.getTurnPlayer());
    	System.out.println(sp.calStateHeuristic(state.getOpponent()));	
    }*/   
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2019-04-10 15:29:08.503
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2019-04-10 15:29:08.504
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2931)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3033)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1390)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:340)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:199)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:265)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:593)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:91)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2019-04-10 15:32:47.865 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-10 15:33:00.762
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-10 15:33:00.861
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-10 15:57:26.890
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-10 17:40:50.648
!MESSAGE Totally 1 type loaders have been loaded.
!SESSION 2019-04-10 19:29:43.564 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-10 19:29:58.013
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-10 19:29:58.106
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-10 19:30:26.191
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-10 20:16:23.953
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-04-11 18:11:26.146 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_161
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.core.net 1 0 2019-04-11 18:12:14.021
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.egit.core 2 0 2019-04-11 18:12:14.136
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY no.simula.se.lmf.runtime 1 0 2019-04-11 18:12:24.743
!MESSAGE Totally 1 type loaders have been loaded.

!ENTRY org.eclipse.equinox.p2.metadata.repository 4 1000 2019-04-11 19:11:51.754
!MESSAGE No repository found at jar:file:/Users/ggsddu/Downloads/no.simula.se.rucm.editor.beta.2016.zip!/.
!SESSION 2019-11-22 18:13:58.962 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=11.0.3
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.modeling.product -keyring /Users/wenzongxia/.eclipse_keyring

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-11-22 18:14:00.797
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [609]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.0.v20170629-1728"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [623]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [65]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:444)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1682)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1661)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1624)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1555)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:340)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-11-22 18:14:00.800
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [611]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.0.v20180221-1812"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [609]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.0.v20170629-1728"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [623]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [65]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:444)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1682)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1661)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1624)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1555)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:340)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-11-22 18:14:00.801
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [623]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [65]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:444)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1682)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1661)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1624)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1555)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:340)

!ENTRY org.eclipse.core.resources 4 567 2019-11-22 18:14:13.248
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-11-22 18:14:13.248
!MESSAGE Could not read metadata for 'pentago-swap'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/pentago-swap)[567]: java.lang.Exception: The project description file (.project) for 'pentago-swap' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:39)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:35)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:903)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:886)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:866)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:718)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1558)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2448)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2205)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:486)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:466)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-11-22 18:14:13.248
!MESSAGE The project description file (.project) for 'pentago-swap' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'pentago-swap' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:39)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:35)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:903)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:886)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:866)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:718)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1558)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2448)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2205)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:486)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:466)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.egit.core 2 0 2019-11-22 18:14:14.464
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:315)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4860)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-11-22 18:14:17.101
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-11-22 18:14:17.101
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'

!ENTRY org.eclipse.core.resources 4 567 2019-11-22 18:14:29.501
!MESSAGE The project description file (.project) for 'pentago-swap' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'pentago-swap' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:39)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:35)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:903)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:886)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:757)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1061)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1107)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:39)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:60)
